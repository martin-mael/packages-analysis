#!/bin/bash
# filepath: analyze-dependencies.sh
#
# Analyse des d√©pendances JavaScript/TypeScript depuis GitHub
# 
# Usage:
#   ./analyse-dependencies.sh [branche]
#
# Exemples:
#   ./analyse-dependencies.sh dev       # Analyse la branche dev
#   ./analyse-dependencies.sh master    # Analyse la branche master

set -e

# Configuration
OUTPUT_FILE="$HOME/Documents/Apps/dependencies-analysis-$(date +%Y%m%d-%H%M%S).csv"

# Liste des repos √† analyser
REPOS=(
    "training.web"
    "crm.web"
    "portal.web"
    "bridge-admin.web"
    "marketing.web"
    "store.web"
    "task-manager"
    "document-manager.web"
    "pdp-gateway.web"
    "messenger"
    "simulators.web"
)

# Variable pour indiquer qu'on utilise GitHub
USE_GITHUB=true

# Branche √† analyser (par d√©faut master)
TARGET_BRANCH="master"

# R√©pertoire temporaire pour le cache des package.json
GITHUB_CACHE_DIR=""

# Fonction pour r√©cup√©rer tous les package.json depuis GitHub
fetch_all_package_json_from_github() {
    local npm_token=""
    if [[ -f "$HOME/.npmrc" ]]; then
        npm_token=$(grep -E "//npm\.pkg\.github\.com/:_authToken=" "$HOME/.npmrc" 2>/dev/null | cut -d'=' -f2)
    fi
    
    if [[ -n "$npm_token" ]]; then
        echo "üì¶ R√©cup√©ration de tous les package.json depuis GitHub (branche: $TARGET_BRANCH)..."
        
        # Cr√©er un r√©pertoire temporaire pour le cache
        GITHUB_CACHE_DIR=$(mktemp -d)
        
        for repo in "${REPOS[@]}"; do
            echo "  üîç R√©cup√©ration $repo/package.json..."
            local package_json_content=$(curl -s -H "Authorization: Bearer $npm_token" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/fulll/$repo/contents/package.json?ref=$TARGET_BRANCH" | \
                jq -r '.content // empty' 2>/dev/null | base64 -d 2>/dev/null)
            
            if [[ -n "$package_json_content" ]]; then
                echo "$package_json_content" > "$GITHUB_CACHE_DIR/$repo.json"
                echo "    ‚úÖ $repo/package.json r√©cup√©r√© (branche: $TARGET_BRANCH)"
            else
                echo "    ‚ùå Impossible de r√©cup√©rer $repo/package.json (branche: $TARGET_BRANCH)"
                # Essayer avec master si main √©choue
                if [[ "$TARGET_BRANCH" == "main" ]]; then
                    echo "    üîÑ Tentative avec la branche master..."
                    package_json_content=$(curl -s -H "Authorization: Bearer $npm_token" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "https://api.github.com/repos/fulll/$repo/contents/package.json?ref=master" | \
                        jq -r '.content // empty' 2>/dev/null | base64 -d 2>/dev/null)
                    
                    if [[ -n "$package_json_content" ]]; then
                        echo "$package_json_content" > "$GITHUB_CACHE_DIR/$repo.json"
                        echo "    ‚úÖ $repo/package.json r√©cup√©r√© (branche: master)"
                    else
                        echo "    ‚ùå Impossible de r√©cup√©rer $repo/package.json (master non plus)"
                        touch "$GITHUB_CACHE_DIR/$repo.json"  # Cr√©er un fichier vide
                    fi
                # Essayer avec main si master √©choue
                elif [[ "$TARGET_BRANCH" == "master" ]]; then
                    echo "    üîÑ Tentative avec la branche main..."
                    package_json_content=$(curl -s -H "Authorization: Bearer $npm_token" \
                        -H "Accept: application/vnd.github.v3+json" \
                        "https://api.github.com/repos/fulll/$repo/contents/package.json?ref=main" | \
                        jq -r '.content // empty' 2>/dev/null | base64 -d 2>/dev/null)
                    
                    if [[ -n "$package_json_content" ]]; then
                        echo "$package_json_content" > "$GITHUB_CACHE_DIR/$repo.json"
                        echo "    ‚úÖ $repo/package.json r√©cup√©r√© (branche: main)"
                    else
                        echo "    ‚ùå Impossible de r√©cup√©rer $repo/package.json (main non plus)"
                        touch "$GITHUB_CACHE_DIR/$repo.json"  # Cr√©er un fichier vide
                    fi
                else
                    touch "$GITHUB_CACHE_DIR/$repo.json"  # Cr√©er un fichier vide
                fi
            fi
        done
        
        echo "‚úÖ Tous les package.json r√©cup√©r√©s depuis GitHub"
        return 0
    else
        echo "‚ùå Token npm non disponible"
        return 1
    fi
}

# Fonction pour nettoyer le cache
cleanup_github_cache() {
    if [[ -n "$GITHUB_CACHE_DIR" && -d "$GITHUB_CACHE_DIR" ]]; then
        rm -rf "$GITHUB_CACHE_DIR"
    fi
}

# Fonction pour extraire la version d'un package depuis GitHub
get_package_version() {
    local repo_name="$1"
    local package_name="$2"
    
    # Utiliser le cache GitHub
    local cache_file="$GITHUB_CACHE_DIR/$repo_name.json"
    
    if [[ -f "$cache_file" && -s "$cache_file" ]]; then
        local version=$(jq -r "(.dependencies // {}) | .[\"$package_name\"] // empty" "$cache_file" 2>/dev/null)
        if [[ "$version" != "null" && "$version" != "" ]]; then
            echo "$version" | sed 's/^[\^~]*//'
        else
            echo "-"
        fi
    else
        echo "-"
    fi
}

# Fonction pour obtenir la version latest d'un package
get_latest_version() {
    local package_name="$1"
    
    # Pour les packages @fulll, utiliser le token npm du .npmrc
    if [[ "$package_name" == @fulll/* ]]; then
        # Extraire le token npm du .npmrc
        local npm_token=""
        if [[ -f "$HOME/.npmrc" ]]; then
            npm_token=$(grep -E "//npm\.pkg\.github\.com/:_authToken=" "$HOME/.npmrc" 2>/dev/null | cut -d'=' -f2)
        fi
        
        if [[ -n "$npm_token" ]]; then
            # Utiliser l'API GitHub Packages avec le token npm
            local package_encoded=$(echo "$package_name" | sed 's/@/%40/g' | sed 's/\//%2F/g')
            local latest=$(curl -s -H "Authorization: Bearer $npm_token" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/orgs/fulll/packages/npm/${package_name#@fulll/}/versions" | \
                jq -r '.[0].name // empty' 2>/dev/null)
            
            if [[ -n "$latest" && "$latest" != "null" ]]; then
                echo "$latest" | sed 's/^v//'
            else
                # Fallback: essayer avec npm view si configur√©
                local npm_version=$(npm view "$package_name" version 2>/dev/null)
                if [[ -n "$npm_version" ]]; then
                    echo "$npm_version"
                else
                    echo "N/A"
                fi
            fi
        else
            echo "N/A"
        fi
    else
        # Pour les autres packages, utiliser npm registry public
        local latest=$(curl -s "https://registry.npmjs.org/$package_name/latest" | \
            jq -r '.version // empty' 2>/dev/null)
        if [[ -n "$latest" && "$latest" != "null" ]]; then
            echo "$latest"
        else
            echo "N/A"
        fi
    fi
}

# Fonction pour collecter toutes les d√©pendances des projets depuis GitHub
collect_all_dependencies() {
    local temp_file=$(mktemp)
    
    for repo in "${REPOS[@]}"; do
        # Utiliser le cache GitHub
        local cache_file="$GITHUB_CACHE_DIR/$repo.json"
        if [[ -f "$cache_file" && -s "$cache_file" ]]; then
            jq -r '(.dependencies // {}) | keys[]' "$cache_file" 2>/dev/null >> "$temp_file"
        fi
    done
    
    # Trier et d√©dupliquer
    sort "$temp_file" | uniq
    rm "$temp_file"
}

# Fonction pour analyser les d√©pendances
analyze_dependencies() {
    echo "üìä Analyse des d√©pendances..."
    
    # Collecter toutes les d√©pendances uniques des projets
    echo "üîç Collecte de toutes les d√©pendances..."
    local all_deps=$(collect_all_dependencies)
    local total_deps=$(echo "$all_deps" | wc -l | tr -d ' ')
    echo "üì¶ $total_deps d√©pendances uniques trouv√©es"
    
    # En-t√™te CSV avec BOM pour Excel
    printf '\xEF\xBB\xBF' > "$OUTPUT_FILE"
    echo "Package,Latest,Training,CRM,Portal,Admin,Marketing,Store,Tasks,Document,PA,Messenger,Simulateur" >> "$OUTPUT_FILE"
    
    # Analyser chaque package trouv√©
    echo "$all_deps" | while read -r package; do
        if [[ -n "$package" ]]; then
            echo "üîç Analyse de $package..."
            local latest_version=$(get_latest_version "$package")
            
            # √âchapper les guillemets et virgules dans les valeurs
            package_escaped=$(echo "$package" | sed 's/"/""""/g')
            latest_escaped=$(echo "$latest_version" | sed 's/"/""""/g')
            
            local row="\"$package_escaped\",\"$latest_escaped\""
            
            for repo in "${REPOS[@]}"; do
                local version=$(get_package_version "$repo" "$package")
                version_escaped=$(echo "$version" | sed 's/"/""""/g')
                row+=",\"$version_escaped\""
            done
            
            echo "$row" >> "$OUTPUT_FILE"
        fi
    done
    
    echo "üìä Analyse termin√©e - $total_deps d√©pendances analys√©es"
}


# Fonction principale
main() {
    echo "üöÄ D√©marrage de l'analyse des d√©pendances depuis GitHub..."
    echo "üìÑ Fichier de sortie: $OUTPUT_FILE"
    echo ""
    
    # V√©rifier si une branche est pass√©e en param√®tre
    if [[ -n "$1" ]]; then
        TARGET_BRANCH="$1"
        echo "üåø Branche sp√©cifi√©e en param√®tre: $TARGET_BRANCH"
    fi
    
    # V√©rifier jq seulement
    if ! command -v jq >/dev/null 2>&1; then
        echo "‚ùå jq n'est pas install√©. Installation:"
        echo "   brew install jq"
        exit 1
    fi
    
    # V√©rifier la configuration npm pour les packages @fulll
    local npm_token=""
    if [[ -f "$HOME/.npmrc" ]]; then
        npm_token=$(grep -E "//npm\.pkg\.github\.com/:_authToken=" "$HOME/.npmrc" 2>/dev/null | cut -d'=' -f2)
    fi
    
    if [[ -n "$npm_token" ]]; then
        echo "‚úÖ Token npm configur√© pour GitHub Packages"
        
        # Choix de la branche seulement si pas pass√©e en param√®tre
        if [[ -z "$1" ]]; then
            echo ""
            echo "üåø Quelle branche voulez-vous analyser ?"
            echo "1) master (par d√©faut)"
            echo "2) dev"
            echo ""
            read -p "Votre choix (1-2, d√©faut=1): " branch_choice
            
            case "$branch_choice" in
                2)
                    TARGET_BRANCH="dev"
                    ;;
            esac
        fi
        
        echo "üìã Branche s√©lectionn√©e: $TARGET_BRANCH"
        echo "üìã Mode GitHub - r√©cup√©ration en lot des package.json"
        
        # R√©cup√©rer tous les package.json en une fois
        if ! fetch_all_package_json_from_github; then
            echo "‚ùå √âchec de la r√©cup√©ration depuis GitHub"
            exit 1
        fi
    else
        echo "‚ùå Token npm non trouv√© dans ~/.npmrc"
        echo "   Pour configurer: npm login --scope=@fulll --auth-type=legacy --registry=https://npm.pkg.github.com"
        exit 1
    fi
    
    echo "üìã Analyse depuis GitHub - Branche: $TARGET_BRANCH - Repos: ${REPOS[*]}"
    echo ""
    
    # Analyser les d√©pendances
    analyze_dependencies
    
    echo ""
    echo "‚úÖ Analyse termin√©e!"
    echo "üìÑ Fichier CSV sauvegard√© dans: $OUTPUT_FILE"
    echo ""
    echo "üîç Pour ouvrir le fichier CSV:"
    echo "   open $OUTPUT_FILE"
    echo ""
    echo "üìä Pour l'ouvrir directement dans Excel:"
    echo "   open -a 'Microsoft Excel' $OUTPUT_FILE"
    echo ""
    echo "üìã Pour l'ouvrir dans Numbers (Mac):"
    echo "   open -a 'Numbers' $OUTPUT_FILE"
    
    # Nettoyer le cache GitHub
    cleanup_github_cache
}

# Nettoyage en cas d'interruption
trap cleanup_github_cache EXIT


# Ex√©cution
main "$@"
